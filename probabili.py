# -*- coding: utf-8 -*-
"""Probabili

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AhaBKJGSbebMR-MxDxkoCQGHk0OI2yYQ
"""

# ==========================================================
#  ‚úÖ SCREENSHOT BOT MULTIFONTE
# ==========================================================

# --- INSTALLAZIONE SILENZIOSA ---
!pip install -q playwright google-auth google-auth-oauthlib \
  google-auth-httplib2 google-api-python-client gspread nest_asyncio pillow > /dev/null 2>&1
!playwright install --with-deps chromium > /dev/null 2>&1
print("üîß Dipendenze installate.")


# ==========================================================
#  LIBRERIE
# ==========================================================
import asyncio, re, os, random, glob
import nest_asyncio
from google.colab import auth
auth.authenticate_user()

from google.auth import default
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
import gspread
from playwright.async_api import async_playwright

# ==========================================================
#  CONFIG
# ==========================================================
SHEET_ID   = "1l8v3uDyzk1A9sMUwoV2L_rhOns-vJRV7iOTRfLK4ZvU"
SHEET_NAME = "Probabili"
DRIVE_FOLDER_ID = "1Oy6nEebc7hE0OOyD3DKnqb3PaGSLk2eO"
GIORNATA = 12
MAX_MATCH = 10

# ==========================================================
#  GOOGLE: connessione
# ==========================================================
SCOPES = ["https://www.googleapis.com/auth/drive",
          "https://www.googleapis.com/auth/spreadsheets"]
creds, _ = default(scopes=SCOPES)
drive_svc = build("drive", "v3", credentials=creds)
sheets_gc = gspread.authorize(creds)
ws = sheets_gc.open_by_key(SHEET_ID).worksheet(SHEET_NAME)
nest_asyncio.apply()

# ==========================================================
#  UTIL
# ==========================================================
def drive_upload_or_replace(local_path, name):
    media = MediaFileUpload(local_path, mimetype="image/png", resumable=False)
    res = drive_svc.files().list(
        q=f"name='{name}' and '{DRIVE_FOLDER_ID}' in parents and trashed=false",
        fields="files(id)", supportsAllDrives=True
    ).execute()
    files = res.get("files", [])
    file_id = files[0]["id"] if files else None
    if file_id:
        drive_svc.files().update(
            fileId=file_id, media_body=media,
            keepRevisionForever=False, supportsAllDrives=True
        ).execute()
    else:
        meta = {"name": name, "parents": [DRIVE_FOLDER_ID], "mimeType": "image/png"}
        file_id = drive_svc.files().create(
            body=meta, media_body=media, fields="id", supportsAllDrives=True
        ).execute()["id"]
        drive_svc.permissions().create(
            fileId=file_id, body={"role": "reader", "type": "anyone"}, fields="id"
        ).execute()
    return f"https://drive.google.com/uc?id={file_id}"

def propaga_match_ad_altre_fonti():
    data = ws.get_all_values()
    if not data:
        print("‚ÑπÔ∏è Foglio vuoto, nessuna propagazione.")
        return
    header, rows = data[0], data[1:]
    col_fonte  = header.index("Fonte")
    col_match  = header.index("Match")

    ref = [r[col_match] for r in rows if r[col_fonte] == "Sos Fanta" and r[col_match]]
    if not ref:
        print("‚ÑπÔ∏è Nessun match di riferimento (Sos Fanta).")
        return

    updates, current, idx = [], None, 0
    for i, r in enumerate(rows, start=2):
        fonte = r[col_fonte]
        if fonte != current:
            current, idx = fonte, 0
        if fonte != "Sos Fanta" and (not r[col_match] or r[col_match].strip() == ""):
            if idx < len(ref):
                updates.append({"range": f"D{i}", "values": [[ref[idx]]]} )
                idx += 1
        elif fonte != "Sos Fanta":
            idx += 1

    if updates:
        ws.batch_update(updates)
        print(f"üü¢ Propagati {len(updates)} 'Match' alle altre fonti.")
    else:
        print("‚ÑπÔ∏è Nessuna cella 'Match' da aggiornare per altre fonti.")

# ==========================================================
#  BLOCCO RICHIESTE PRIVACY (banner cookie RCS)
# ==========================================================
async def block_privacy_requests(route):
    url = route.request.url
    if any(x in url for x in [
        "privacy.rcs.it", "sp-prod.net", "consent.cookiebot.com", "cdn.privacy-mgmt.com"
    ]):
        await route.abort()
    else:
        await route.continue_()

# ==========================================================
#  FONTE 1: SosFanta
# ==========================================================
async def estrai_screenshots_sosfanta():
    FONTE = "Sos Fanta"
    URL = "https://www.sosfanta.com/lista-formazioni/probabili-formazioni-serie-a/"
    rows = []

    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True, args=["--no-sandbox","--disable-dev-shm-usage"])
        context = await browser.new_context(viewport={"width":1600,"height":4000})
        page = await context.new_page()
        await page.goto(URL, wait_until="domcontentloaded", timeout=60000)

        # COOKIE
        for sel in [
            "button:has-text('Accetta e continua')",
            "button:has-text('Accetta')",
            "text='ACCETTA E CONTINUA'"
        ]:
            try:
                await page.locator(sel).first.click(timeout=3000)
                await page.wait_for_timeout(700)
                break
            except:
                pass

        # Mostra tutte le partite
        try:
            btn = await page.query_selector(".scheduled-matches__list .match-cell[match='ALL']")
            if btn:
                await page.evaluate("b => { b.scrollIntoView({block:'center'}); b.click(); }", btn)
                await asyncio.sleep(1.2)
        except:
            pass

        # Scroll per caricare
        for box in await page.query_selector_all("div[id]"):
            _id = await box.get_attribute("id")
            if not _id or not re.match(r"^[A-Z]{3}-[A-Z]{3}(-\d+)?$", _id):
                continue
            await page.evaluate("el => el.scrollIntoView({block:'center'})", box)
            await asyncio.sleep(1.2)

        # Legge ID partite
        ids = []
        for el in await page.query_selector_all("div[id]"):
            _id = (await el.get_attribute("id")) or ""
            if re.match(r"^[A-Z]{3}-[A-Z]{3}(-\d+)?$", _id):
                ids.append(_id)

        ids = ids[:MAX_MATCH]
        # LOG pulito (niente lista dettagliata degli ID)
        print(f"üîé SosFanta: trovate {len(ids)} partite")

        # LOOP PARTITE
        for idx, dom_id in enumerate(ids, start=1):
            a, b, _ = dom_id.split("-")
            if a == "HEL": a = "VER"
            if b == "HEL": b = "VER"
            match_txt = f"{a} - {b}"

            filename = f"sosfanta_{idx}.png"
            raw_path = f"/content/raw_{filename}"
            final_path = f"/content/{filename}"

            try:
                # Rimuove header
                await page.evaluate("""
                    dom_id => {
                        const box = document.getElementById(dom_id);
                        if (!box) return;

                        box.classList.remove('is-hidden');
                        box.style.display='block';
                        box.style.opacity=1;

                        const heads = box.querySelectorAll('.bck-gn-match-formation-teams');
                        heads.forEach(h => h.remove());
                    }
                """, dom_id)

                await page.evaluate("""
                    dom_id => {
                        const box = document.getElementById(dom_id);
                        if (!box) return;

                        const notes = box.querySelector('.bck-gn-match-formation-teams-notes');
                        if (!notes) return;

                        const labels = [...notes.querySelectorAll('.note-label')];
                        const indis = labels.find(el => el.textContent.trim().toLowerCase() === "indisponibili");
                        if (!indis) return;

                        const container = indis.parentElement;
                        const columns = container.querySelector(".columns");
                        if (!columns) return;

                        // Reset totale layout
                        container.style.display = "flex";
                        container.style.flexDirection = "column";
                        container.style.alignItems = "center";
                        container.style.width = "100%";
                        container.style.textAlign = "center";

                        columns.style.display = "flex";
                        columns.style.flexDirection = "column";
                        columns.style.alignItems = "center";
                        columns.style.justifyContent = "center";
                        columns.style.width = "100%";
                        columns.style.maxWidth = "600px";
                        columns.style.margin = "0 auto";
                        columns.style.gap = "10px";

                        // Rimuove tutte le classi Bulma residue
                        columns.className = "";

                        // FIX DECISIVO: reset di ogni stile ereditato dai testi
                        const teams = columns.querySelectorAll('.note-team');
                        teams.forEach(t => {
                            t.style.textAlign = "center";
                            t.style.margin = "0 auto";
                            t.style.float = "none";
                            t.style.width = "100%";
                            t.style.display = "block";

                            // Rimuove classi che Bulma applica sui testi
                            t.classList.remove("has-text-right");
                            t.classList.remove("is-pulled-right");
                            t.classList.remove("has-text-left");
                        });

                        // Rimuove resti di struttura colonne
                        columns.querySelectorAll('[class*="column"]').forEach(col => {
                            col.className = "";
                            col.style.margin = "0 auto";
                            col.style.padding = "0";
                            col.style.textAlign = "center";
                            col.style.display = "block";
                            col.style.width = "100%";
                        });
                    }
                """, dom_id)

                # Scroll su box
                await page.evaluate(
                    "dom_id => document.getElementById(dom_id).scrollIntoView({block:'center'})",
                    dom_id
                )
                await page.wait_for_timeout(800)

                # ---- SCREENSHOT RAW ----
                container = await page.query_selector(f"div#{dom_id}")
                await container.screenshot(path=raw_path)

                # ---- CROP LATERALE 120px ----
                from PIL import Image
                img = Image.open(raw_path)
                w, h = img.size
                cropped = img.crop((120, 0, w - 120, h))
                cropped.save(final_path)

                # Upload
                link = drive_upload_or_replace(final_path, filename)
                rows.append([FONTE, GIORNATA, idx, match_txt, link])
                print(f"‚úÖ SosFanta | {match_txt} ‚Üí {filename}")

            except Exception as e:
                print(f"‚ö†Ô∏è SosFanta errore su {match_txt}: {e}")

        await context.close()
        await browser.close()

    if rows:
        ws.update(range_name=f"A2:E{1+len(rows)}", values=rows)
        print(f"üü¢ Foglio aggiornato (SosFanta): {len(rows)} righe.")



# ==========================================================
#  FONTE 2: Fantacalcio (CON CHIUSURA POPUP CMP)
# ==========================================================
async def estrai_screenshots_fantacalcio():
    FONTE = "Fantacalcio"
    URL = "https://www.fantacalcio.it/probabili-formazioni-serie-a"
    rows = []

    async with async_playwright() as p:
        browser = await p.chromium.launch(
            headless=True,
            args=["--no-sandbox", "--disable-dev-shm-usage"]
        )
        context = await browser.new_context(
            viewport={"width": 1600, "height": 4000}
        )
        page = await context.new_page()

        # --- Caricamento pagina ---
        await page.goto(URL, wait_until="domcontentloaded", timeout=60000)
        await page.wait_for_timeout(1200)

        # ======================================================
        # üî• CHIUSURA POPUP CMP (Quantcast, FundingChoices, ecc.)
        # ======================================================
        try:
            await page.wait_for_selector(
                "button:has-text('OK'), button:has-text('Continue'), button[mode='primary']",
                timeout=5000
            )
            for sel in [
                "button:has-text('OK')",
                "button:has-text('Ok')",
                "button:has-text('OK, I AGREE')",
                "button:has-text('CONTINUE')",
                "button:has-text('Continue')",
                "button[mode='primary']"
            ]:
                try:
                    await page.locator(sel).click(timeout=800)
                    await page.wait_for_timeout(400)
                    break
                except:
                    pass
        except:
            pass

        # ======================================================
        #   COOKIE FALLBACK (vecchi popup)
        # ======================================================
        for sel in [
            "button:has-text('Accetta')",
            "button:has-text('Accetta e continua')",
            "text='CONFIRM'",
            "button:has-text('Confirm')"
        ]:
            try:
                await page.locator(sel).first.click(timeout=2500)
                await page.wait_for_timeout(600)
                break
            except:
                pass

        # Forza rimozione overlay residui
        await page.evaluate("""
            () => {
                document.documentElement.style.overflow='auto';
                document.body.style.overflow='auto';
                document.querySelectorAll('[role="dialog"], .fc-consent-root, .modal, .popup').forEach(e=>e.remove());
            }
        """)

        # ======================================================
        #   CARICAMENTO PARTITE
        # ======================================================
        await page.wait_for_selector("li.match.match-item", timeout=15000)
        matches = await page.query_selector_all("li.match.match-item")

        print(f"üîé Fantacalcio: trovate {len(matches)} partite")

        # ======================================================
        #   LOOP PARTITE
        # ======================================================
        for idx, match in enumerate(matches, start=1):

            # ---- BLOCCO A: div.row.col-sm ----
            blockA = await match.query_selector("div.row.col-sm")
            pathA = f"/content/fantaA_{idx}.png"
            if blockA:
                # Forza larghezza a contenitore completo
                await page.evaluate("""
                    el => {
                        el.style.width = "100%";
                        el.style.boxSizing = "border-box";
                    }
                """, blockA)
                await blockA.screenshot(path=pathA)
            else:
                pathA = None


            # ---- BLOCCO B: section.mt-4.match-graphs.burn ----
            blockB = await match.query_selector("section.mt-4.match-graphs.burn")
            pathB = f"/content/fantaB_{idx}.png"
            if blockB:
                # Forza larghezza identica al blocco A
                await page.evaluate("""
                    el => {
                        el.style.width = "100%";
                        el.style.boxSizing = "border-box";
                    }
                """, blockB)
                await blockB.screenshot(path=pathB)
            else:
                pathB = None


            # ---- UNIONE DELLE IMMAGINI ----
            final_path = f"/content/fantacalcio_{idx}.png"

            from PIL import Image

            imgs = []
            if pathA:
                imgs.append(Image.open(pathA))
            if pathB:
                imgs.append(Image.open(pathB))

            if not imgs:
                print(f"‚ö†Ô∏è Fantacalcio | partita {idx}: nessun blocco trovato")
                continue

            widths = [i.width for i in imgs]
            heights = [i.height for i in imgs]

            final_width = max(widths)
            final_height = sum(heights)

            final_img = Image.new("RGB", (final_width, final_height), (255, 255, 255))

            y_offset = 0
            for im in imgs:
                final_img.paste(im, (0, y_offset))
                y_offset += im.height

            final_img.save(final_path)

            # ---- Upload Drive ----
            link = drive_upload_or_replace(final_path, f"fantacalcio_{idx}.png")
            rows.append([FONTE, GIORNATA, idx, f"Partita {idx}", link])

            print(f"‚úÖ Fantacalcio | Partita {idx} ‚Üí fantacalcio_{idx}.png")

        # ======================================================
        #   CHIUSURA E AGGIORNAMENTO FOGLIO
        # ======================================================
        await context.close()
        await browser.close()

        if rows:
            all_vals = ws.get_all_values()
            start = next(i for i, r in enumerate(all_vals, start=1) if i > 1 and r[0] == "Fantacalcio")
            ws.update(
                range_name=f"A{start}:E{start + len(rows) - 1}",
                values=rows
            )
            print(f"üü¢ Foglio aggiornato (Fantacalcio): {len(rows)} righe.")
        else:
            print("‚ÑπÔ∏è Nessuna riga scritta per Fantacalcio.")


# ==========================================================
#  FONTE 3: Gazzetta.it
# ==========================================================
from PIL import Image, ImageOps

async def estrai_screenshots_gazzetta():
    FONTE = "Gazzetta"
    URL = "https://www.gazzetta.it/Calcio/prob_form/"
    START_ROW_GAZZETTA = 12  # inizio scrittura colonna E

    async with async_playwright() as p:
        browser = await p.chromium.launch(
            headless=True, args=["--no-sandbox", "--disable-dev-shm-usage"]
        )
        context = await browser.new_context(viewport={"width": 1600, "height": 4000})
        await context.route("**/*", block_privacy_requests)
        page = await context.new_page()

        # --- 1Ô∏è‚É£ Caricamento pagina ---
        await page.goto(URL, wait_until="domcontentloaded", timeout=60000)

        # --- 2Ô∏è‚É£ Gestione banner cookie ---
        try:
            await page.wait_for_selector("button:has-text('ACCETTA E CONTINUA')", timeout=6000)
            await page.locator("button:has-text('ACCETTA E CONTINUA')").click()
            await page.wait_for_load_state("networkidle")
            await page.wait_for_timeout(1200)
        except:
            pass  # banner non essenziale da loggare

        # --- 3Ô∏è‚É£ Pulizia overlay privacy/consent ---
        try:
            await page.wait_for_load_state("networkidle")
            await page.evaluate("""
                () => {
                    const patterns = ['sp_message','qc-cmp','cmp','consent','privacy'];
                    document.querySelectorAll('iframe,[role="dialog"],div').forEach(el=>{
                        const html=(el.outerHTML||'').toLowerCase();
                        if (patterns.some(k=>html.includes(k))) el.remove();
                    });
                    if (document.body) document.body.style.overflow='auto';
                    if (document.documentElement) document.documentElement.style.overflow='auto';
                }
            """)
        except Exception:
            pass  # eventuali errori qui non bloccano lo script

        # --- 4Ô∏è‚É£ Selezione dei box partita ---
        await page.wait_for_selector(".bck-box-match-details", timeout=25000)
        matches = await page.query_selector_all(".bck-box-match-details")
        print(f"üîé Gazzetta: trovate {len(matches)} partite")

        success = 0  # per log finale "Foglio aggiornato"

        # --- 5Ô∏è‚É£ Loop sulle partite ---
        for idx, match_box in enumerate(matches[:MAX_MATCH], start=1):
            try:
                dom_id = await match_box.get_attribute("id") or f"match_{idx}"

                # Forza rendering
                await match_box.scroll_into_view_if_needed()
                await page.wait_for_timeout(1500)

                # Attesa caricamento lineup
                try:
                    await page.wait_for_selector(f"#{dom_id} .match-details__lineup",
                                                 state="attached", timeout=4000)
                except:
                    print(f"‚ö†Ô∏è Gazzetta | Match {idx}: lineup non ancora caricata (lazy).")

                lineup = await page.query_selector(f"#{dom_id} .match-details__lineup")
                notes = await page.query_selector(f"#{dom_id} .match-details__notes")

                if not lineup and not notes:
                    print(f"‚ö†Ô∏è Gazzetta | Match {idx}: sezioni non trovate, salto.")
                    continue

                # --- Rimuove prime due righe delle note ---
                if notes:
                    await page.evaluate("""
                        (sel) => {
                            const el = document.querySelector(sel);
                            if (!el) return;
                            const rows = el.querySelectorAll('.match-details__note-row, .match-details_note-row');
                            rows.forEach((r, i) => { if (i < 2) r.remove(); });
                        }
                    """, f"#{dom_id} .match-details__notes")

                # --- Allarga notes al 100% ---
                if notes:
                    await page.evaluate("""
                        (sel) => {
                            const el = document.querySelector(sel);
                            if (el) {
                                el.style.width = '100%';
                                el.style.maxWidth = '100%';
                                el.style.margin = '0';
                                el.style.padding = '0';
                            }
                        }
                    """, f"#{dom_id} .match-details__notes")

                # --- Screenshot lineup ---
                lineup_path = None
                if lineup:
                    await lineup.scroll_into_view_if_needed()
                    await page.wait_for_timeout(800)
                    lineup_path = f"/content/gazzetta_{idx}_lineup.png"
                    await lineup.screenshot(path=lineup_path)

                # --- Screenshot notes ---
                notes_path = None
                if notes:
                    await notes.scroll_into_view_if_needed()
                    await page.wait_for_timeout(800)
                    notes_path = f"/content/gazzetta_{idx}_notes.png"
                    await notes.screenshot(path=notes_path)

                # ======================================================
                #     üî• 6Ô∏è‚É£ UNIONE + FIX FORMATO (NOTES IN COLONNA)
                # ======================================================

                images = [Image.open(p) for p in [lineup_path, notes_path] if p]
                if not images:
                    continue

                lineup_img = images[0]
                notes_img  = images[1] if len(images) == 2 else None

                rosa = (253, 233, 235)

                # ======================================================
                # 1Ô∏è‚É£ TAGLIO LINEUP ‚Üí 175px a sinistra e 175px a destra
                # ======================================================

                cut_left  = 175
                cut_right = 175

                if lineup_img.width > cut_left + cut_right:
                    lineup_img = lineup_img.crop((
                        cut_left,
                        0,
                        lineup_img.width - cut_right,
                        lineup_img.height
                    ))

                base_width = lineup_img.width


                # ======================================================
                # 2Ô∏è‚É£ TROVA LA COLONNA DI SEPARAZIONE NOTE (SX/DX)
                #     INVECE DI TAGLIARE A META'
                # ======================================================

                if notes_img:

                    w, h = notes_img.width, notes_img.height
                    notes_pixels = notes_img.load()

                    # Scansione verticale della met√† centrale per individuare la colonna bianca
                    best_col = None
                    min_dark = 999999

                    # analizziamo 15 colonne centrali (tolleranza)
                    for offset in range(-7, 8):
                        x = w // 2 + offset
                        dark = 0
                        for y in range(0, h, 6):   # campionamento ogni 6px
                            r,g,b = notes_pixels[x, y]
                            if (r+g+b) < 690:      # pixel non bianco
                                dark += 1

                        if dark < min_dark:
                            min_dark = dark
                            best_col = x

                    if best_col is None:
                        best_col = w // 2   # fallback sicurezza

                    # TAGLIO COLONNE NOTE
                    notes_left  = notes_img.crop((0, 0, best_col, h))
                    notes_right = notes_img.crop((best_col, 0, w, h))

                    # ======================================================
                    # 3Ô∏è‚É£ RIDUZIONE NOTES AL 88% DELLA LARGHEZZA LINEUP
                    # ======================================================

                    scale_notes = 0.88
                    new_width   = int(base_width * scale_notes)

                    def resize_ratio(im, target_w):
                        ratio = target_w / im.width
                        new_h = int(im.height * ratio)
                        return im.resize((target_w, new_h), resample=Image.LANCZOS)

                    notes_left  = resize_ratio(notes_left,  new_width)
                    notes_right = resize_ratio(notes_right, new_width)

                    # ======================================================
                    # 4Ô∏è‚É£ UNIONE NOTE IN COLONNA (SX sopra, DX sotto)
                    # ======================================================

                    # --- Separator con margini sopra e sotto ---
                    sep_height = 4
                    sep_margin = 10  # <‚îÄ‚îÄ spazio sopra e sotto

                    separator_full = Image.new("RGB", (new_width, sep_height + sep_margin * 2), rosa)
                    separator_line = Image.new("RGB", (new_width, sep_height), (210, 190, 190))

                    # incolla la linea al centro verticale
                    separator_full.paste(separator_line, (0, sep_margin))

                    # --- Calcolo altezza nuova colonna ---
                    notes_column_height = (
                        notes_left.height +
                        separator_full.height +
                        notes_right.height
                    )

                    notes_column = Image.new("RGB", (new_width, notes_column_height), rosa)

                    # --- Costruzione della colonna ---
                    y = 0
                    notes_column.paste(notes_left, (0, y))
                    y += notes_left.height

                    notes_column.paste(separator_full, (0, y))
                    y += separator_full.height

                    notes_column.paste(notes_right, (0, y))


                    # ======================================================
                    # 5Ô∏è‚É£ CENTRA NOTES RISULTANTI ALLA LARGHEZZA LINEUP
                    # ======================================================

                    delta = (base_width - new_width) // 2
                    notes_img = ImageOps.expand(
                        notes_column,
                        border=(delta, 0, base_width - new_width - delta, 0),
                        fill=rosa
                    )
                else:
                    notes_img = None


                # ======================================================
                # 6Ô∏è‚É£ COMBINA LINEUP + GAP 30 PX + NOTES
                # ======================================================

                gap = 30
                gap_block = Image.new("RGB", (base_width, gap), rosa)

                if notes_img:
                    total_height = lineup_img.height + gap + notes_img.height
                else:
                    total_height = lineup_img.height

                combined = Image.new("RGB", (base_width, total_height), rosa)

                y = 0
                combined.paste(lineup_img, (0, y))

                if notes_img:
                    y += lineup_img.height
                    combined.paste(gap_block, (0, y))
                    y += gap
                    combined.paste(notes_img, (0, y))


                # ======================================================
                # 7Ô∏è‚É£ PADDING FINALE PER GLIDE 9:16
                # ======================================================

                combined = ImageOps.expand(
                    combined,
                    border=(20, 40, 20, 40),   # left, top, right, bottom
                    fill=rosa
                )

                combined_path = f"/content/gazzetta_{idx}.png"
                combined.save(combined_path)

                # --- Upload su Drive e aggiornamento foglio ---
                link = drive_upload_or_replace(combined_path, f"gazzetta_{idx}.png")
                row = START_ROW_GAZZETTA + idx - 1
                ws.update(range_name=f"E{row}", values=[[link]])

                success += 1
                print(f"‚úÖ Gazzetta | Match {idx} ‚Üí gazzetta_{idx}.png")

            except Exception as e:
                print(f"‚ö†Ô∏è Gazzetta errore su match {idx}: {e}")

        # --- Chiusura browser ---
        await context.close()
        await browser.close()

        if success:
            print(f"üü¢ Foglio aggiornato (Gazzetta): {success} righe.")
        else:
            print("‚ÑπÔ∏è Nessuna riga scritta per Gazzetta.")


# ==========================================================
#  MANAGER
# ==========================================================
async def aggiorna_tutte_le_fonti():
    await estrai_screenshots_sosfanta()
    await estrai_screenshots_fantacalcio()
    await estrai_screenshots_gazzetta()
    propaga_match_ad_altre_fonti()

# ==========================================================
#  ESECUZIONE
# ==========================================================
# ‚ñ∂Ô∏è Per testare solo SosFanta:
# await estrai_screenshots_sosfanta()

# ‚ñ∂Ô∏è Per testare solo Fantacalcio:
await estrai_screenshots_fantacalcio()

# ‚ñ∂Ô∏è Per testare solo Gazzetta:
# await estrai_screenshots_gazzetta()

# ‚ñ∂Ô∏è Per eseguire tutto:
# await aggiorna_tutte_le_fonti()